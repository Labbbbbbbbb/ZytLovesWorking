# 1. 视频采集 
自动拍摄一段视频，保存在`/data/video/test.mp4`
``` python
from media.vencoder import *
from media.sensor import *
from media.media import *
from media.display import *
import time, os

def vi_bind_venc_test(file_name, width=1280, height=720):
    print("VENC 测试开始")
    venc_chn = VENC_CHN_ID_0
    width = ALIGN_UP(width, 16)
    venc_payload_type = K_PT_H265

    # 初始化传感器
    sensor = Sensor()
    sensor.reset()
    sensor.set_framesize(width=width, height=height, alignment=12)
    sensor.set_pixformat(Sensor.YUV420SP)
    
    sensor.set_framesize(width=800, height=480, chn=CAM_CHN_ID_1)
    sensor.set_pixformat(Sensor.YUV420SP, chn=CAM_CHN_ID_1)
    Display.init(Display.ST7701, width=800, height=480, to_ide=True)
    sensor_bind_info = sensor.bind_info(x = 0, y = 0, chn = CAM_CHN_ID_1)
    Display.bind_layer(**sensor_bind_info, layer = Display.LAYER_VIDEO1)
    


    # 实例化视频编码器
    encoder = Encoder()
    encoder.SetOutBufs(venc_chn, 8, width, height)

    # 绑定camera和venc
    link = MediaManager.link(sensor.bind_info()['src'], (VIDEO_ENCODE_MOD_ID, VENC_DEV_ID, venc_chn))

    # init media manager
    MediaManager.init()

    if (venc_payload_type == K_PT_H264):
        chnAttr = ChnAttrStr(encoder.PAYLOAD_TYPE_H264, encoder.H264_PROFILE_MAIN, width, height)
    elif (venc_payload_type == K_PT_H265):
        chnAttr = ChnAttrStr(encoder.PAYLOAD_TYPE_H265, encoder.H265_PROFILE_MAIN, width, height)

    streamData = StreamData()

    # 创建编码器
    encoder.Create(venc_chn, chnAttr)

    # 开始编码
    encoder.Start(venc_chn)
    # 启动camera
    sensor.run()

    frame_count = 0
    print("save stream to file: ", file_name)

    with open(file_name, "wb") as fo:
        try:
            while True:
                os.exitpoint()
                encoder.GetStream(venc_chn, streamData) # 获取一帧码流

                for pack_idx in range(0, streamData.pack_cnt):
                    stream_data = uctypes.bytearray_at(streamData.data[pack_idx], streamData.data_size[pack_idx])
                    fo.write(stream_data) # 码流写文件
                    print("stream size: ", streamData.data_size[pack_idx], "stream type: ", streamData.stream_type[pack_idx])

                encoder.ReleaseStream(venc_chn, streamData) # 释放一帧码流

                frame_count += 1
                if frame_count >= 2000:
                    break
        except KeyboardInterrupt as e:
            print("user stop: ", e)
        except BaseException as e:
            import sys
            sys.print_exception(e)

    # 停止camera
    sensor.stop()
    
    Display.deinit()
    # 销毁camera和venc的绑定
    del link
    # 停止编码
    encoder.Stop(venc_chn)
    # 销毁编码器
    encoder.Destroy(venc_chn)
    # 清理buffer
    MediaManager.deinit()
    print("venc_test stop")
    image_folder = "/data/video"
    
try:
	os.stat(image_folder)  # 尝试获取目录信息
except OSError:
	os.mkdir(image_folder)  # 若失败则创建该目录
	
if __name__ == "__main__":
    os.exitpoint(os.EXITPOINT_ENABLE)
    vi_bind_venc_test("/data/video/test.mp4",1920,1080)  # vi绑定venc示例
```
# 2. 照片采集
按下侧边按钮，记录一张图片，保存在`/data/images`
```python
import time, os, sys

#使用默认摄像头，可选参数:0,1,2.
sensor_id = 2

# ========== 多媒体/图像相关模块 ==========
from media.sensor import Sensor, CAM_CHN_ID_0
from media.display import Display
from media.media import CAM_CHN_ID_1, MediaManager
import image

# ========== GPIO/按键/LED相关模块 ==========
from machine import Pin
from machine import FPIOA

# ========== 创建FPIOA对象并为引脚功能分配 ==========
fpioa = FPIOA()
fpioa.set_function(62, FPIOA.GPIO62)   # 红灯
fpioa.set_function(20, FPIOA.GPIO20)   # 绿灯
fpioa.set_function(63, FPIOA.GPIO63)   # 蓝灯
fpioa.set_function(53, FPIOA.GPIO53)   # 按键

# ========== 初始化LED (共阳：高电平熄灭，低电平亮) ==========
LED_R = Pin(62, Pin.OUT, pull=Pin.PULL_NONE, drive=7)  # 红灯
LED_G = Pin(20, Pin.OUT, pull=Pin.PULL_NONE, drive=7)  # 绿灯
LED_B = Pin(63, Pin.OUT, pull=Pin.PULL_NONE, drive=7)  # 蓝灯

# 默认熄灭所有LED
LED_R.high()
LED_G.high()
LED_B.high()

# 选一个LED用来拍照提示
PHOTO_LED = LED_G

# ========== 初始化按键：按下时高电平 ==========
button = Pin(53, Pin.IN, Pin.PULL_DOWN)
debounce_delay = 200  # 按键消抖时长(ms)
last_press_time = 0
button_last_state = 0

# ========== 显示配置 ==========
DISPLAY_MODE = "LCD"   # 可选："VIRT","LCD","HDMI"
DISPLAY_WIDTH = 800
DISPLAY_HEIGHT = 480
FPS = 60


def lckfb_save_jpg(img, filename, quality=95):
    """
    将图像压缩成JPEG后写入文件 (不依赖第一段 save_jpg/MediaManager.convert_to_jpeg 的写法)
    :param img:    传入的图像对象 (Sensor.snapshot() 得到)
    :param filename: 保存的目标文件名 (含路径)
    :param quality:  压缩质量 (1-100)
    """
    compressed_data = img.compress(quality=quality)

    with open(filename, "wb") as f:
        f.write(compressed_data)

    print(f"[INFO] 使用 lckfb_save_jpg() 保存完毕: {filename}")


# ========== 自动创建图片保存文件夹 & 计算已有图片数量 ==========
image_folder = "/data/images"

# 若不存在该目录则创建
try:
    os.stat(image_folder)  # 尝试获取目录信息
except OSError:
    os.mkdir(image_folder)  # 若失败则创建该目录

# 统计当前目录下以 “lckfb_XX.jpg” 命名的文件数量，自动从最大编号继续
image_count = 0
existing_images = [fname for fname in os.listdir(image_folder)
                   if fname.startswith("lckfb_") and fname.endswith(".jpg")]

if existing_images:
    # 提取编号并找出最大值
    numbers = []
    for fname in existing_images:
        # 假设文件名格式为 "lckfb_XX.jpg"
        # 取中间 XX 部分转为数字
        try:
            num_part = fname[6:11]  # "lckfb_" 长度为6，取到 ".jpg" 前还要注意下标
            numbers.append(int(num_part))
        except:
            pass
    if numbers:
        image_count = max(numbers)

try:
    print("[INFO] 初始化摄像头 ...")
    sensor = Sensor(id=sensor_id)
    sensor.reset()

    # 在本示例中使用 VGA (640x480) 做演示
    sensor.set_framesize(width=DISPLAY_WIDTH, height=DISPLAY_HEIGHT, chn=CAM_CHN_ID_0)
    sensor.set_pixformat(Sensor.RGB888, chn=CAM_CHN_ID_0)

    sensor.set_framesize(width=1920, height=1080, chn=CAM_CHN_ID_1)
    sensor.set_pixformat(Sensor.RGB888, chn=CAM_CHN_ID_1)
    
    
    # ========== 初始化显示 ==========
    if DISPLAY_MODE == "VIRT":
        Display.init(Display.VIRT, width=DISPLAY_WIDTH, height=DISPLAY_HEIGHT, fps=FPS)
    elif DISPLAY_MODE == "LCD":
        Display.init(Display.ST7701, width=DISPLAY_WIDTH, height=DISPLAY_HEIGHT, to_ide=True, osd_num=2)
    elif DISPLAY_MODE == "HDMI":
        Display.init(Display.LT9611, width=DISPLAY_WIDTH, height=DISPLAY_HEIGHT, to_ide=True)

    # ========== 初始化媒体管理器 ==========
    MediaManager.init()

    # ========== 启动摄像头 ==========
    sensor.run()
    print("[INFO] 摄像头已启动，进入主循环 ...")

    fps = time.clock()

    while True:
        fps.tick()
        os.exitpoint()



        #按键处理（检测上升沿）
        current_time = time.ticks_ms()
        button_state = button.value()

        if button_state == 1 and button_last_state == 0:  # 上升沿
            if current_time - last_press_time > debounce_delay:
                # LED闪烁提示
                PHOTO_LED.low()   # 点亮LED

                #抓取通道0的图像
                img = sensor.snapshot(chn=CAM_CHN_ID_1)
                # 拍照并保存
                image_count += 1
                filename = f"{image_folder}/lckfb_{image_count:05d}_{img.width()}x{img.height()}.jpg"
                print(f"[INFO] 拍照保存 -> {filename}")

                # 直接调用自定义的 lckfb_save_jpg() 函数
                lckfb_save_jpg(img, filename, quality=95)
                
                PHOTO_LED.high()  # 熄灭LED

                last_press_time = current_time

        button_last_state = button_state

        #抓取通道0的图像
        osd_img = sensor.snapshot(chn=CAM_CHN_ID_0)
        osd_img.draw_string_advanced(0, 0, 32, str(image_count), color=(255, 0, 0))
        osd_img.draw_string_advanced(0, DISPLAY_HEIGHT-32, 32, str(fps.fps()), color=(255, 0, 0))

        Display.show_image(osd_img, 0, 0, Display.LAYER_OSD3)

except KeyboardInterrupt:
    print("[INFO] 用户停止")
except BaseException as e:
    print(f"[ERROR] 出现异常: {e}")
finally:
    if 'sensor' in locals() and isinstance(sensor, Sensor):
        sensor.stop()
    Display.deinit()
    os.exitpoint(os.EXITPOINT_ENABLE_SLEEP)
    time.sleep_ms(100)
    MediaManager.deinit()
```
